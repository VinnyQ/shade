#!/usr/bin/env python
# Copyright 2014 Richard Hawkins
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import ctypes
import os

from OpenGL import GL as gl
import sdl2

import transylvania
from transylvania import sprites
from transylvania import tiled


GAME_DIR = os.path.dirname(os.path.realpath(__file__))


class Player(object):

    def __init__(self, group):
        self.group = group
        group.add(self)
        self.sprite = sprites.build(os.path.join(GAME_DIR, 'player.png'))
        self.rect = transylvania.Rect((320, 240), self.sprite.get_size())
        self.resting = False
        self.dy = 0

    def update(self, dt, g):
        last = self.rect.copy()

        state = transylvania.get_keyboard_state()
        if state[sdl2.scancode.SDL_SCANCODE_LEFT]:
            self.rect.x -= 300 * dt
        if state[sdl2.scancode.SDL_SCANCODE_RIGHT]:
            self.rect.x += 300 * dt

        if self.resting and state[sdl2.scancode.SDL_SCANCODE_UP]:
            self.dy = -900
        self.dy = min(400, self.dy + 40)
        self.rect.y -= self.dy * dt

        new = self.rect
        self.resting = False
        for cell in transylvania.spritecollide(self, g.walls_group, False):
            cell = cell.rect
            if last.right <= cell.left and new.right > cell.left:
                new.right = cell.left
            if last.left >= cell.right and new.left < cell.right:
                new.left = cell.right
            if last.bottom >= cell.top and new.bottom < cell.top:
                self.resting = True
                new.bottom = cell.top
                self.dy = 0
            if last.top <= cell.bottom and new.top > cell.bottom:
                new.top = cell.bottom
                self.dy = 0

        # set the camera to put the player in the middle of the screen
        self.group.camera_x = self.rect.x - 320

    def draw(self, proj_matrix, view_matrix):
        self.sprite.draw(proj_matrix, view_matrix, self.rect.x, self.rect.y, 1)


class Wall(object):
    def __init__(self, sprite, rect=None):
        if not rect:
            rect = transylvania.Rect()
        self.sprite = sprite
        self.rect = rect

    def update(self, *args, **kwargs):
        pass

    def draw(self, proj_matrix, view_matrix):
        self.sprite.draw(proj_matrix, view_matrix, self.rect.x, self.rect.y, 2)


class ScrollGroup(transylvania.SpriteGroup):
    def draw(self, proj_matrix, view_matrix):
        [s.draw(proj_matrix, view_matrix, self.rect.x, self.rect.y, 1) for s in self]


class Game(object):
    def main(self, width, height):

        clock = transylvania.Clock()
        window = transylvania.set_display_mode(width, height)

        background = sprites.build(os.path.join(GAME_DIR, 'background.png'))
        self.sprite_group = transylvania.SpriteGroup()
        self.sprite_group.camera_x = 0
        self.player = Player(self.sprite_group)

        self.walls_group = transylvania.SpriteGroup()
        block = sprites.build(os.path.join(GAME_DIR, 'block.png'))
        for x in range(0, 800, 32):
            for y in range(0, 480, 32):
                if x in (0, 800-32) or y in (0, 480-32):
                    wall = Wall(block, transylvania.Rect((x, y), block.get_size()))
                    self.walls_group.add(wall)
        self.sprite_group.add(self.walls_group)

        running = True
        event = sdl2.SDL_Event()

        while running:
            dt = clock.tick(30)
            while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:
                if event.type == sdl2.SDL_QUIT:
                    running = False
                if (event.type == sdl2.SDL_KEYDOWN and
                        event.key.keysym.sym == sdl2.keycode.SDLK_ESCAPE):
                    running = False

            self.sprite_group.update(dt / 1000., self)

            gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
            proj_matrix = transylvania.gmath.get_projection_matrix(
                0.0, width, 0.0, height)
            view_matrix = transylvania.gmath.get_4x4_transform(trans_x=-self.sprite_group.camera_x, trans_y=0)

            background.draw(proj_matrix, view_matrix, 0, 0)
            self.sprite_group.draw(proj_matrix, view_matrix)

            sdl2.SDL_GL_SwapWindow(window)


if __name__ == '__main__':
    transylvania.init()
    Game().main(640, 480)
